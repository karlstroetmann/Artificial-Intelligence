import pygame
import sys
import math
import time

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
BACKGROUND_COLOR = (240, 248, 255)  # Alice Blue
PEG_COLOR = (139, 69, 19)      # Saddle Brown
DISK_COLORS = [
    (255, 0, 0), (255, 165, 0), (255, 255, 0), (0, 128, 0),
    (0, 0, 255), (75, 0, 130), (238, 130, 238), (128, 0, 128),
    (0, 255, 255), (0, 128, 128)
] # List of colors for disks
PEG_WIDTH = 15
PEG_HEIGHT = 300
BASE_HEIGHT = 20
DISK_MIN_WIDTH = 40
DISK_HEIGHT = 20
ANIMATION_SPEED = 6  # Pixels per frame (adjust for faster/slower animation)
LIFT_HEIGHT = 50   # How high above the peg the disk lifts

# --- Peg Positions ---
PEG_Y = SCREEN_HEIGHT - BASE_HEIGHT - PEG_HEIGHT
BASE_Y = SCREEN_HEIGHT - BASE_HEIGHT
PEG_X = [SCREEN_WIDTH * (i / 4.0) for i in [1, 2, 3]] # X-coordinates for the 3 pegs

# --- Global Variables ---
screen = None
clock = None
towers = []  # List of lists representing disks on pegs (bottom to top)
moves = []   # List of move tuples (disk_index, src_peg, dest_peg) generated by solver
current_move_index = 0
animation_state = "IDLE"  # States: IDLE, LIFTING, MOVING_HORIZONTALLY, DROPPING, FINISHED
moving_disk_index = None
moving_disk_pos = [0, 0] # Current [x, y] of the moving disk's top-left
target_pos = [0, 0]      # Target [x, y] for the current animation phase
num_disks = 0
disk_params = {} # Will store calculated widths, heights, colors per disk

# --- Functions ---

def get_num_disks():
    """Gets the number of disks from the user via console input."""
    while True:
        try:
            n_str = input(f"Enter the number of disks (e.g., 3 to 8): ")
            n = int(n_str)
            if 1 <= n <= 10: # Limit to 10 disks for reasonable animation time
                return n
            else:
                print("Please enter a number between 1 and 10.")
        except ValueError:
            print("Invalid input. Please enter an integer.")
        except EOFError: # Handle cancelled input (e.g., Ctrl+D)
             print("\nInput cancelled. Exiting.")
             return None


def hanoi_solver(n, source, destination, auxiliary):
    """
    Recursively generates the moves for the Towers of Hanoi puzzle.
    Appends moves as (disk_index, source_peg, destination_peg) tuples to the global 'moves' list.
    Note: disk_index is 0-based (0 is smallest, n-1 is largest).
    """
    if n > 0:
        # Move n-1 disks from source to auxiliary, using destination as auxiliary
        hanoi_solver(n - 1, source, auxiliary, destination)

        # Move the nth disk (index n-1) from source to destination
        disk_index_to_move = n - 1
        moves.append((disk_index_to_move, source, destination))
        # print(f"Move disk {disk_index_to_move} from {source} to {destination}") # For debugging

        # Move n-1 disks from auxiliary to destination, using source as auxiliary
        hanoi_solver(n - 1, auxiliary, destination, source)

def calculate_disk_params(n_disks):
    """Calculates dimensions and colors for each disk."""
    params = {'widths': [], 'height': DISK_HEIGHT, 'colors': []}
    max_width = PEG_X[1] - PEG_X[0] - PEG_WIDTH * 1.5 # Max width based on peg spacing
    if max_width < DISK_MIN_WIDTH: max_width = DISK_MIN_WIDTH * 1.5

    for i in range(n_disks):
        # Width decreases linearly from max_width for largest disk (n-1)
        # to DISK_MIN_WIDTH for smallest disk (0)
        width = DISK_MIN_WIDTH + (max_width - DISK_MIN_WIDTH) * (i / (n_disks -1 if n_disks > 1 else 1))
        params['widths'].append(int(width))
        params['colors'].append(DISK_COLORS[i % len(DISK_COLORS)])
    return params

def get_disk_rect(disk_idx, peg_idx, position_in_stack):
    """
    Calculates the pygame.Rect for a specific disk in its resting position on a peg.
    position_in_stack: 0 is the bottom-most disk on the peg.
    """
    disk_width = disk_params['widths'][disk_idx]
    disk_height = disk_params['height']
    peg_center_x = PEG_X[peg_idx]
    disk_x = peg_center_x - disk_width / 2
    disk_y = BASE_Y - (position_in_stack + 1) * disk_height
    return pygame.Rect(disk_x, disk_y, disk_width, disk_height)

def draw_pegs():
    """Draws the base and the three pegs."""
    # Draw Base
    pygame.draw.rect(screen, PEG_COLOR, (0, BASE_Y, SCREEN_WIDTH, BASE_HEIGHT))
    # Draw Pegs
    for x in PEG_X:
        peg_rect = pygame.Rect(x - PEG_WIDTH / 2, PEG_Y, PEG_WIDTH, PEG_HEIGHT)
        pygame.draw.rect(screen, PEG_COLOR, peg_rect)

def draw_disks():
    """Draws all disks currently resting on the pegs."""
    for peg_idx, peg_content in enumerate(towers):
        for stack_pos, disk_idx in enumerate(peg_content):
            # Don't draw the disk if it's currently being animated
            if animation_state != "IDLE" and disk_idx == moving_disk_index:
                continue
            disk_rect = get_disk_rect(disk_idx, peg_idx, stack_pos)
            pygame.draw.rect(screen, disk_params['colors'][disk_idx], disk_rect, border_radius=4)
            # Optional: Draw black border
            pygame.draw.rect(screen, (0,0,0), disk_rect, width=1, border_radius=4)


def draw_moving_disk():
    """Draws the disk that is currently being animated."""
    if moving_disk_index is not None:
        disk_width = disk_params['widths'][moving_disk_index]
        disk_height = disk_params['height']
        moving_rect = pygame.Rect(moving_disk_pos[0], moving_disk_pos[1], disk_width, disk_height)
        pygame.draw.rect(screen, disk_params['colors'][moving_disk_index], moving_rect, border_radius=4)
        # Optional: Draw black border
        pygame.draw.rect(screen, (0,0,0), moving_rect, width=1, border_radius=4)


def start_next_move():
    """Initiates the animation sequence for the next move in the list."""
    global animation_state, moving_disk_index, moving_disk_pos, target_pos, current_move_index

    if current_move_index >= len(moves):
        print("Animation Finished!")
        animation_state = "FINISHED"
        return

    disk_idx, src_peg, dest_peg = moves[current_move_index]

    # --- Validation (Should not happen with correct Hanoi logic) ---
    if not towers[src_peg] or towers[src_peg][-1] != disk_idx:
         print(f"Error: Trying to move disk {disk_idx} from peg {src_peg}, but it's not on top!")
         print(f"Current towers state: {towers}")
         print(f"Move attempting: {moves[current_move_index]}")
         animation_state = "FINISHED" # Stop animation on error
         return
    # --- End Validation ---


    moving_disk_index = towers[src_peg].pop() # Remove disk from source tower data

    # Calculate initial position (top of source peg)
    source_stack_height = len(towers[src_peg])
    initial_rect = get_disk_rect(moving_disk_index, src_peg, source_stack_height)
    moving_disk_pos[0] = initial_rect.left
    moving_disk_pos[1] = initial_rect.top

    # Set target for LIFTING phase
    target_pos[0] = moving_disk_pos[0]
    target_pos[1] = PEG_Y - LIFT_HEIGHT - disk_params['height'] # Lift above pegs
    if target_pos[1] < 0 : target_pos[1] = 0 # Don't go off screen top

    animation_state = "LIFTING"

def update_animation():
    """Updates the position of the moving disk based on the current animation state."""
    # Add this line to declare intent to use global variables
    global animation_state, moving_disk_pos, target_pos, current_move_index, moving_disk_index

    if animation_state == "IDLE" or animation_state == "FINISHED":
        return

    # Calculate movement vector
    dx = target_pos[0] - moving_disk_pos[0]
    dy = target_pos[1] - moving_disk_pos[1]
    distance = math.sqrt(dx**2 + dy**2)

    if distance < ANIMATION_SPEED:
        # Reached target for the current phase
        moving_disk_pos[0] = target_pos[0]
        moving_disk_pos[1] = target_pos[1]

        # --- Transition to next state ---
        if animation_state == "LIFTING":
            animation_state = "MOVING_HORIZONTALLY"
            _, src_peg, dest_peg = moves[current_move_index]
            # Calculate target X for horizontal move (center disk over dest peg)
            dest_peg_center_x = PEG_X[dest_peg]
            # Use the global moving_disk_index here - it's now correctly accessed
            disk_width = disk_params['widths'][moving_disk_index]
            target_pos[0] = dest_peg_center_x - disk_width / 2
            # Y position remains the lifted height for this phase
            target_pos[1] = moving_disk_pos[1]


        elif animation_state == "MOVING_HORIZONTALLY":
            animation_state = "DROPPING"
            _, _, dest_peg = moves[current_move_index]
            # Calculate target Y for dropping onto destination peg
            dest_stack_height = len(towers[dest_peg])
            final_y = BASE_Y - (dest_stack_height + 1) * disk_params['height']
            target_pos[0] = moving_disk_pos[0] # X remains the same
            target_pos[1] = final_y

        elif animation_state == "DROPPING":
            # Finished dropping, finalize the move
            _, _, dest_peg = moves[current_move_index]
            towers[dest_peg].append(moving_disk_index) # Add disk to destination tower data
            # Assigning to the global variable now
            moving_disk_index = None # Reset moving disk
            current_move_index += 1
            animation_state = "IDLE" # Ready for next move (or finished)

    else:
        # Move towards target
        moving_disk_pos[0] += (dx / distance) * ANIMATION_SPEED
        moving_disk_pos[1] += (dy / distance) * ANIMATION_SPEED    


# --- Main Function ---
def main():
    global screen, clock, num_disks, towers, moves, current_move_index, animation_state, disk_params

    num_disks = get_num_disks()
    if num_disks is None:
        sys.exit() # User cancelled input

    # Calculate disk parameters based on the number of disks
    disk_params = calculate_disk_params(num_disks)

    # Initialize Pygame
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption(f"Towers of Hanoi ({num_disks} Disks)")
    clock = pygame.time.Clock()

    # Initialize Tower State
    towers = [list(range(num_disks - 1, -1, -1)), [], []] # Disk 0 is smallest, n-1 is largest

    # Generate Moves
    moves = []
    start_time = time.time()
    hanoi_solver(num_disks, 0, 2, 1) # Solve from peg 0 to peg 2 using peg 1
    end_time = time.time()
    print(f"Generated {len(moves)} moves in {end_time - start_time:.4f} seconds.")


    # Reset animation state variables
    current_move_index = 0
    animation_state = "IDLE"
    moving_disk_index = None

    # Game Loop
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_ESCAPE: # Allow exiting with Esc key
                     running = False

        # --- Update Logic ---
        if animation_state == "IDLE" and current_move_index < len(moves):
            start_next_move()
        elif animation_state != "IDLE" and animation_state != "FINISHED":
            update_animation()

        # --- Drawing ---
        screen.fill(BACKGROUND_COLOR)
        draw_pegs()
        draw_disks()          # Draw disks on pegs
        draw_moving_disk()    # Draw the animating disk (if any)

        pygame.display.flip() # Update the full screen
        clock.tick(60)       # Limit frame rate to 60 FPS

    pygame.quit()
    sys.exit()

# --- Run the Game ---
if __name__ == '__main__':
    main()
